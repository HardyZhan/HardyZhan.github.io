<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Head First Java | HardyZhan</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico?v=1648713301592">
<link rel="stylesheet" href="http://localhost:4000/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="Head First Java
primitive主数据类型

boolean (java虚拟机决定其位数) true/false
char    16bits              0~65535
byte    8bits     ..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="http://localhost:4000">
        <img src="http://localhost:4000/images/avatar.png?v=1648713301592" class="site-logo">
        <h1 class="site-title">HardyZhan</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      分享我的世界
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="http://localhost:4000/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Head First Java</h2>
            <div class="post-date">2022-03-31</div>
            
            <div class="post-content" v-pre>
              <h1 id="head-first-java">Head First Java</h1>
<h3 id="primitive主数据类型">primitive主数据类型</h3>
<ul>
<li><code>boolean</code> (java虚拟机决定其位数) true/false</li>
<li><code>char</code>    16bits              0~65535</li>
<li><code>byte</code>    8bits               -128~127</li>
<li><code>short</code>   16bits              -32768~32767</li>
<li><code>int</code>     32bits              -2147483648~2147483647</li>
<li><code>float</code>   32bits              范围规模可变</li>
</ul>
<h3 id="伪码">伪码</h3>
<ul>
<li>实例变量的声明</li>
<li>方法的声明</li>
<li>方法的逻辑(最重要)</li>
</ul>
<h3 id="arraylist类">ArrayList类</h3>
<h4 id="常用方法">常用方法</h4>
<ul>
<li><code>add(Object elem) // 向list中加入对象参数</code></li>
<li><code>remove(int index) // 在索引参数中移除对象</code></li>
<li><code>remove(Object elem) // 移除该对象</code></li>
<li><code>contains(Object elem) // 如果和对象参数匹配返回“true”</code></li>
<li><code>isEmpty() // 如果list中没有元素返回“true”</code></li>
<li><code>indexOf(Object elem) // 返回对象参数的索引或-1</code></li>
<li><code>size() // 返回list中元素的一个数</code></li>
<li><code>get(int index) // 返回当前索引参数的对象</code></li>
</ul>
<h4 id="操作">操作</h4>
<h6 id="创建">创建</h6>
<pre><code>ArrayList&lt;Egg&gt; myList = new ArrayList&lt;Egg&gt;(); 
//Egg可以为任意数据类型,且不需要指定大小
</code></pre>
<h6 id="加入元素">加入元素</h6>
<pre><code>Egg s = new Egg();
myList.add(s);
Egg b = new Egg();
myList.add(b);
</code></pre>
<h6 id="查询大小">查询大小</h6>
<p><code>int theSize = myList.size();</code></p>
<h6 id="查询特定元素">查询特定元素</h6>
<p><code>boolean isIn = myList.contains(s);</code></p>
<h6 id="查询特定元素的位置">查询特定元素的位置</h6>
<p><code>int idx = myList.indexOf(b);</code></p>
<h6 id="判断集合是否为空">判断集合是否为空</h6>
<p><code>boolean empty = myList.isEmpty();</code></p>
<h6 id="删除元素">删除元素</h6>
<p><code>myList.remove(s);</code></p>
<h3 id="多态">多态</h3>
<ul>
<li>运用多态时，引用类型可以是实际对象类型的父类<br><br>
例子：<br><pre><code>Animal[] animals = new Animal[5];
animals [0] = new Dog();
animals [1] = new Cat();
animals [2] = new Wolf();
animals [3] = new Hippo();
animals [4] = new Lion();
for (int i = 0; i &lt; animals.length; i ++) {
animals[i].eat(); //当i为0时，调用Dog的eat()
animals[i].roam(); //当i为1时，调用Cat的eat()
}
</code></pre>
</li>
<li>参数和返回类型也可以多态</li>
</ul>
<h3 id="三种防止某个类被作出子类的方法">三种防止某个类被作出子类的方法</h3>
<ul>
<li>存取控制<br><br>
就算类不能标记为私有，但是它还是可以不标记为公有。非公有的类只能被同一个包的类做出子类。</li>
<li>使用<code>final</code>修饰符<br><br>
这表示它是继承树的末端，不能被继承。</li>
<li>让类只拥有<code>private</code>的构造程序</li>
</ul>
<h3 id="calendar运用">Calendar运用</h3>
<p>Calendar是一个抽象类，无法取得实例，但可以通过<code>Calendar.getInstance()</code>来取得它的具体子类的实例。</p>
<ul>
<li>重要方法</li>
</ul>
<pre><code>   add(int field, int acmount); //加减时间值
   get(int field); //取出指定字段的值
   getInstance(); //返回Calendar，可指定地区
   getTimeInMillis(); //以毫秒返回时间
   roll(int field, boolean up); //加减时间值，不进位
   set(int field, int value); //设定指定字段的值
   set(year, month, day, hour, minute); //设定完整的时间
   setTimeInMiliis(long millis); //以毫秒指定时间
   ...
</code></pre>
<ul>
<li>关键字段</li>
</ul>
<pre><code>   DATE / DAY_OF_MONTH //每月的几号
   HOUR / HOUR_OF_DAY //小时
   MILLISENCOND //毫秒
   MINUTE //分钟
   MONTH //月份
   YEAR //年份
   ZONE_OFFSET //时区位移
   ...
</code></pre>
<h3 id="异常处理">异常处理</h3>
<ul>
<li>编译器不会注意RuntimeException类型的异常。RuntimeException不需要声明或被包在try/catch的块中（然而你还是可以这么做）。</li>
</ul>
<h3 id="内部类">内部类</h3>
<ul>
<li>内部类可以使用外部类所有的方法与变量，就算是私用的也一样。</li>
<li>内部类把存取外部类的方法和变量当作是开自家冰箱。</li>
</ul>
<h3 id="序列化和文件的输入输出">序列化和文件的输入/输出</h3>
<ul>
<li>FileOutputStream把字节写入文件;<br><br>
ObjectOutputStream把对象转换成可以写入串流的数据;<br><br>
当我们调用ObjectOutputStream的writeObject时，对象会被打成串流送到FileOutputStream来写入文件.</li>
<li>当对象被序列化时，被该对象引用的实例变量也会被序列化。且所有被引用的对象也会被序列化。</li>
<li>如果要让某类能够被序列化，该类就必须实现Serializable，即<code>implements Serializable</code>。</li>
<li>如果某实例变量不能或不应该被序列化，就把它标记为<code>transient</code>（瞬时）的，例如：<code>transient String currentID</code>。</li>
</ul>
<h3 id="多线程">多线程</h3>
<ul>
<li>Runnable这个接口只有一个方法:<code>public void run()</code>。</li>
<li>Thread对象不可以重复使用，一旦线程的<code>run()</code>方法完成之后，该线程就不能再重新启动了。</li>
<li>使用<code>synchronized</code>这个关键词来修饰方法使它每次只能被单一的线程存取。可用其来修饰一行或数行的指令而不必整个方法都同步化。</li>
<li>使用同步化的程序要小心死锁。死锁会发生是因为两个线程互相持有对方正在等待的东西。</li>
<li><code>Thread.sleep()</code>让所有的线程都有机会运行。</li>
<li>如果两个或以上的线程存取堆上相同的对象可能会出现严重的问题，可能会引发数据的损毁。</li>
<li>每个对象都有单一的锁，单一的钥匙。这只会在对象带有同步化方法时才有实际的用途。</li>
<li>对象有锁，每个被载入的类也有个锁。当要对静态的方法做同步化时，Java会使用类本身的锁。</li>
</ul>
<h3 id="集合与泛型">集合与泛型</h3>
<ul>
<li><code>public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; list)</code><br><br>
与<br><br>
<code>public void takeThing(ArrayList&lt;Animal&gt; list)</code><br><br>
是不一样的。第一个表示任何被声明为Animal或Animal的子型的ArrayList是合法的；但第二个只能使用Animal的ArrayList。<br>
这是不是违背了多态？不不是，详见P571.</li>
<li>以泛型的观点来说，<code>extends</code>代表<code>extends</code>或<code>implement</code>。例如：<br><br>
<code>public static &lt;T extends Compare&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code><br><br>
其中，<code>Compare</code>是一个接口，但是用的是<code>extends</code>。</li>
<li>数组的类型是在运行期间检查的，但集合的类型检查只会发生在编译期间。</li>
<li>在使用带有&lt;?&gt;的声明时，编译器不会让你加入任何东西到集合中。</li>
<li>在方法参数中使用万用字符时，编译器会阻止任何可能破坏引用参数锁指集合的行为。</li>
</ul>
<h3 id="位操作">位操作</h3>
<p>定义<code>int x = -11 // 位组合是11110101</code></p>
<ul>
<li>右移运算符:<code>&gt;&gt;</code> <br><br>
以指定量右移字节合，左方用符号位填充，正负号不变。<br><br>
<code>int y = x &gt;&gt; 2 // 位组合是11111101</code></li>
<li>无符号右移运算符:<code>&gt;&gt;&gt;</code> <br><br>
与<code>&gt;&gt;</code>一样，但第一个位也会补0，正负号可能会改变。<br><br>
<code>int y = x &gt;&gt;&gt; 2; // 位组合是00111101</code></li>
<li>左移运算符:<code>&lt;&lt;</code> <br><br>
与<code>&gt;&gt;&gt;</code>一样，但方向相反；右方补0，正负号可能改变。<br><br>
<code>int y = x &lt;&lt; 2; // 位组合是11010100</code></li>
</ul>
<h3 id="stringbuffer和stringbuilder的方法">StringBuffer和StringBuilder的方法</h3>
<p>Java API中最常用到的类包括了String和StringBuffer（因为String是不变的，使用StringBuffer/StringBuilder来操作String比较有效率）。</p>
<ul>
<li><code>StringBxxxx delete(int start, int end); // 删除部分</code></li>
<li><code>StringBxxxx insert(int offset, any primitive or a char[]); // 插入</code></li>
<li><code>StringBxxxx replace(int start, int end, String s); // 取代</code></li>
<li><code>StringBxxxx reverse(); // 翻转</code></li>
<li><code>void setCharAt(int index, char ch); // 替换字符</code></li>
</ul>
<h3 id="hashcode和equals的相关规定"><code>hashCode()</code>和<code>equals()</code>的相关规定</h3>
<p>API文件有对对象的状态指定出必须遵守的规则：</p>
<ol>
<li>如果两个对象相等，则hashcode必须也是相等的。</li>
<li>如果两个对象相等，对其中一个对象调用<code>equals()</code>必须返回true。也就是说，若<code>a.equals(b)</code>则<code>b.equals(a)</code>。</li>
<li>如果两个对象有相同的hashcode值，他们也不一定是相等的。但若两个对象相等，则hashcode值一定是相等的。</li>
<li>因此若<code>equals()</code>被覆盖过，则<code>hashCode()</code>也必须被覆盖。</li>
<li><code>hashCode()</code>的默认行为是对heap上的对象产生独特的值。如果你没有override过<code>hashCode()</code>，则该class的两个对象怎样的都不会被认为是相同的。</li>
<li><code>equals()</code>的默认行为是执行<code>==</code>的比较。也就是说会去测试两个引用是否对上heap上同一个对象。如果<code>equals()</code>没有被覆盖过，两个对象永远都不会被视为相同的，因为不同的对象有不同的字节组合。<br><br>
<code>a.equals(b)</code>必须与<code>a.hashCode() == b.hashCode()</code>等值。<br><br>
但<code>a.hashCode() == b.hashCode()</code>不一定要与<code>a.equals()</code>等值。</li>
</ol>
<h3 id="为什么不同对象会有相同的hashcode的可能">为什么不同对象会有相同的hashcode的可能？</h3>
<p>因为<code>hashCode()</code>所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关。</p>
<h3 id="tips">TIPS</h3>
<ol>
<li>任何有值被引用到的地方，都可以调用方法的方式来取得该类型的值。</li>
<li><code>null</code>代表没有从奥做对象的远程控制，它是个引用而不是对象。</li>
<li>使用<code>==</code>来比较两个primitive主数据类型，或者判断两个引用是否引用同一个对象；使用<code>equals()</code>来判断两个对象是否在意义上相等。</li>
<li><code>long</code>类型的<code>01011101</code>转化为<code>short</code>类型时，左边的字节会被砍掉，变成<code>1101</code></li>
<li>在使用短运算符(例如:<code>&amp;&amp;</code>或<code>||</code>)时，Java虚拟机若发现作坊表达式不满足条件时不会计算右方的表达式；而长运算符(<code>&amp;</code>或<code>|</code>)使用在<code>boolean</code>表达式时会强制Java虚拟机一定要计算运算符两边的算式。</li>
<li><code>public</code>类型的成员会被继承，<code>private</code>类型的成员不会被继承。</li>
<li>非抽象类中不能拥有抽象方法。一个具体类必须要实现所有抽象的方法，即被重写。</li>
<li>非primitive的变量只是保存对象的引用而已，而不是对象本身。</li>
<li>构造函数不会被继承。</li>
<li>如果实例对象是个对对象的引用，则引用与对象都是在堆上。</li>
<li>实例变量有默认值，原始的默认值是<code>0/0.0/false</code>，引用的默认值是<code>null</code>。</li>
<li>对<code>super()</code>的调用必须是构造函数的第一个语句。</li>
<li>使用<code>this()</code>来从某个构造函数调用同一个类的另一个构造函数；<br><br>
<code>this()</code>只能用在构造函数中，且必须是第一行语句；<br><br>
<code>super()</code>和<code>this()</code>不能兼得。</li>
<li><code>final</code>的变量代表你不能改变它的值；<br><br>
<code>final</code>的method代表你不能覆盖掉该method；<br>
<code>final</code>的类代表你不能继承该类(也就是创建它的子类)。</li>
<li>格式化说明：<br><br>
<code>%[argument number][flags][width][.precision]type</code><br><br>
<strong>argument</strong>:如果格式化的参数超过一个以上，可以在这里指定是哪一个;<br><br>
<strong>flags</strong>:特定类型的特定选项，例如数字要加逗号或正负号;<br><br>
<strong>width</strong>:最小的字符数，注意:这不是总数；输出可以超过此宽度，若不足则会主动补零;<br><br>
<strong>.precision</strong>:精确度，注意前面有个圆点符号;<br><br>
<strong>type</strong>:一定要指定的类型标识符;</li>
</ol>
<ul>
<li>完整的日期与时间:<code>%tc</code></li>
<li>只有时间:<code>%tr</code></li>
<li>周、月、日:<code>%tA %tB %td</code><br>
<br><br>
<br><br>
例子:<br><br>
<code>format(&quot;%,6.1f&quot;,42.000) // 除了没有argument number,其它项目都有。</code></li>
</ul>
<ol start="16">
<li>TCP的端口号是个16位的值。</li>
</ol>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="http://localhost:4000/post/hello-gridea/">
                  <h3 class="post-title">
                    Hello Gridea
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
